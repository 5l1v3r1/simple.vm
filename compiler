#!/usr/bin/perl -w
#
# This is a simple compiler which will read an input file
# and spit out the corresponding bytecodes for the program.
#
# The only real complexity comes from having to account for labels
# as our virtual machine only understands absolute jumps.
#
#      e.g. Rather than "jmp $+3", or "jmp $-8" we can only write
#           "jump address", where "address" is an integer 0-64k.
#
# To cope with this we initially write all jump-targets as
# "JMP 0x0000" and keep track of the length of each instruction
# we've generated.
#
# After the whole program has been compiled we can go back and fill
# in the absolute/real destination for the jumps.
#
# Not ideal, but it is simpler than either parsing for-real or
# using a multi-pass parser.
#
#
# Steve
# --
#


use strict;
use warnings;


#
#  These are the bytecodes we understand.
#
use constant EXIT => 0x00;

#
#  Integer things.
#
use constant INT_STORE    => 0x01;
use constant INT_PRINT    => 0x02;
use constant INT_TOSTRING => 0x03;

#
#  Jumps
#
use constant JUMP_TO => 0x10;
use constant JUMP_Z  => 0x11;
use constant JUMP_NZ => 0x12;


#
#  Mathematical
#
use constant XOR_OP => 0x20;
use constant ADD_OP => 0x21;
use constant SUB_OP => 0x22;
use constant MUL_OP => 0x23;
use constant DIV_OP => 0x24;
use constant INC_OP => 0x25;
use constant DEC_OP => 0x26;


#
#  String operations
#
use constant STRING_STORE  => 0x30;
use constant STRING_PRINT  => 0x31;
use constant STRING_CONCAT => 0x32;
use constant STRING_SYSTEM => 0x33;
use constant STRING_TOINT  => 0x34;


#
#  Comparison functions
#
use constant CMP_REG       => 0x40;
use constant CMP_IMMEDIATE => 0x41;


#
#  Misc things
#
use constant NOP_OP => 0x50;


#
#  Load from RAM/store in RAM
#
use constant LOAD_FROM_RAM => 0x60;
use constant STORE_IN_RAM  => 0x61;


#
#  Labels - All are downcased and must be unique per-source.
#
my %LABELS;


#
#  A running list of the jump-destinations we've got to update
# post-compilation - see the note in the header.
#
my @UPDATES;




#
#  Get the input file we'll parse
#
while ( my $file = shift )
{

    #
    #  Compiled programs have the same basename, but will have a .raw
    # suffix appended.
    #
    my $output = $file;
    $output =~ s/\.[^.]+$//;
    $output .= ".raw";

    #
    #  Open our input/output files.
    #
    open( my $in,  "<", $file )   or die "Failed to read source $file - $!";
    open( my $out, ">", $output ) or die "Failed to write to $output - $!";


    #
    #  Amount of instructions we've output.
    #
    #  As instructions aren't the same lengths we need to
    # ensure we keep track of them so we can calculate jumping
    # offsets.
    #
    my $offset = 0;

    #
    #  Process each line of the input
    #
    while ( my $line = <$in> )
    {

        #
        #  Except comments / empty lines.
        #
        chomp($line);
        next if ( !length($line) || ( $line =~ /^\s*#/ ) );


        #
        #  Label definition ":foo"
        #
        if ( $line =~ /^\s*:(.*)/ )
        {
            my $name = $1;
            $LABELS{ $name } = $offset;

            # so we found a label - store the offset of the code in our array.
        }
        elsif ( $line =~ /^\s*store\s+#([0-9]+)\s*,\s*([0-9]+)/i )
        {
            my $reg = $1;
            my $val = $2;

            die "Int too large" if ( $val >= 65535 );

            my $val1 = $val % 256;
            my $val2 = ( $val - $val1 ) / 256;

            print $out chr INT_STORE;
            print $out chr $reg;
            print $out chr $val1;
            print $out chr $val2;

            $offset += 4;
        }
        elsif ( $line =~ /^\s+exit/ )
        {
            print $out chr EXIT;
            $offset += 1;
        }
        elsif ( $line =~ /^\s+nop/ )
        {
            print $out chr NOP_OP;
            $offset += 1;
        }
        elsif ( $line =~ /^\s+store\s+#([0-9]+)\s?,\s?"([^"]*)"/ )
        {
            my $reg = $1;
            my $str = $2;
            my $len = length($str);

            print $out chr STRING_STORE;
            print $out chr $reg;
            print $out chr $len;
            print $out $str;

            $offset += 3;              # store + reg + len
            $offset += length($str);
        }
        elsif ( $line =~ /^\s*print_int\s?#(.*)/ )
        {
            my $reg = $1;

            print $out chr INT_PRINT;
            print $out chr $reg;
            $offset += 2;
        }
        elsif ( $line =~ /^\s*print_str\s?#(.*)/ )
        {
            my $reg = $1;

            print $out chr STRING_PRINT;
            print $out chr $reg;
            $offset += 2;
        }
        elsif ( $line =~ /^\s*system\s?#(.*)/ )
        {
            my $reg = $1;

            print $out chr STRING_SYSTEM;
            print $out chr $reg;
            $offset += 2;
        }
        elsif ( $line =~ /^\s*goto\s+([^ ]+)/ )
        {
            my $label = $1;

            print $out chr JUMP_TO;
            print $out chr 0;    # this will be updated.
            print $out chr 0;    # this will be updated.

            $offset += 3;        # jump + val1 + val2

            #
            # we now need to record the fact we have to patch up this
            # instruction.
            #
            push( @UPDATES,
                  {  offset => ( $offset - 2 ),
                     label  => $label
                  } );
        }
        elsif ( $line =~ /^\s*jmpz\s+([^ ]+)/ )
        {
            my $label = $1;

            print $out chr JUMP_Z;
            print $out chr 0;    # this will be updated.
            print $out chr 0;    # this will be updated.

            $offset += 3;        # jump + val1 + val2

            #
            # we now need to record the fact we have to patch up this
            # instruction.
            #
            push( @UPDATES,
                  {  offset => ( $offset - 2 ),
                     label  => $label
                  } );
        }
        elsif ( $line =~ /^\s*jmpnz\s+([^ ]+)/ )
        {
            my $label = $1;

            print $out chr JUMP_NZ;
            print $out chr 0;    # this will be updated.
            print $out chr 0;    # this will be updated.

            $offset += 3;        # jump + val1 + val2

            #
            # we now need to record the fact we have to patch up this
            # instruction.
            #
            push( @UPDATES,
                  {  offset => ( $offset - 2 ),
                     label  => $label
                  } );
        }
        elsif ( $line =~
            /^\s*(add|sub|mul|div|xor|concat)\s+#([0-9]+)\s*,\s*#([0-9]+)\s*,\s*#([0-9]+)/
          )
        {

            #
            #  All these operations have args of the form:
            #
            #   OPERATION Result-Register, SrcReg1, SrcReg2
            #
            my %maths = ( add    => ADD_OP,
                          sub    => SUB_OP,
                          mul    => MUL_OP,
                          div    => DIV_OP,
                          xor    => XOR_OP,
                          concat => STRING_CONCAT,
                        );

            my $opr  = $1;
            my $dest = $2;
            my $src1 = $3;
            my $src2 = $4;


            print $out chr $maths{ lc $opr };
            print $out chr $dest;
            print $out chr $src1;
            print $out chr $src2;

            $offset += 4;    # op + dest + src1 + src2
        }
        elsif ( $line =~ /^\s*dec\s+#([0-9]+)/ )
        {
            my $reg = $1;

            print $out chr DEC_OP;
            print $out chr $reg;

            $offset += 2;
        }
        elsif ( $line =~ /^\s*inc\s+#([0-9]+)/ )
        {
            my $reg = $1;

            print $out chr INC_OP;
            print $out chr $reg;

            $offset += 2;
        }
        elsif ( $line =~ /^\s*int2string\s+#([0-9]+)/ )
        {
            my $reg = $1;

            print $out chr INT_TOSTRING;
            print $out chr $reg;
            $offset += 2;
        }
        elsif ( $line =~ /^\s*string2int\s+#([0-9]+)/ )
        {
            my $reg = $1;

            print $out chr STRING_TOINT;
            print $out chr $reg;
            $offset += 2;
        }
        elsif ( $line =~ /^\s*cmp\s+#([0-9]+)\s*,\s*#([0-9]+)\s*/i )
        {
            my $reg1 = $1;
            my $reg2 = $2;

            print $out chr CMP_REG;
            print $out chr $reg1;
            print $out chr $reg2;

            $offset += 3;
        }
        elsif ( $line =~ /^\s*cmp\s+#([0-9]+)\s*,\s*([0-9]+)\s*/i )
        {
            my $reg = $1;
            my $val = $2;

            my $val1 = $val % 256;
            my $val2 = ( $val - $val1 ) / 256;

            print $out chr CMP_IMMEDIATE;
            print $out chr $reg;
            print $out chr $val1;
            print $out chr $val2;

            $offset += 4;    # cmp reg val1 val2
        }
        elsif ( $line =~ /^\s*load\s+#([0-9]+)\s*,\s*#([0-9]+)/ )
        {
            my $reg  = $1;
            my $addr = $2;
            print $out chr LOAD_FROM_RAM;
            print $out chr $reg;
            print $out chr $addr;

            $offset += 3;
        }
        elsif ( $line =~ /^\s*store\s+#([0-9]+)\s*,\s*#([0-9]+)/ )
        {
            my $reg  = $1;
            my $addr = $2;
            print $out chr STORE_IN_RAM;
            print $out chr $reg;
            print $out chr $addr;
            $offset += 3;
        }
        else
        {
            print "WARNING UNKNOWN LINE: $line\n";
        }
    }


    close($in);
    close($out);

    #
    #  OK now this is nasty - we want to go back and patch up the jump
    # instructions we know we've emitted.
    #
    foreach my $update (@UPDATES)
    {
        my $offset = $update->{ 'offset' };
        my $label  = $update->{ 'label' };

        #
        #  Open for in-place editing and make sure we're at the right spot.
        #
        open( my $tmp, "+<", $output ) or die "Failed to write to output - $!";
        seek $tmp, $offset, 0;

        #
        # now we find the target of the label
        #
        my $target = $LABELS{ $label };
        die "No target for label '$label'" unless ( defined($target) );

        #
        # Split the address into two bytes.
        #
        my $t1 = $target % 256;
        my $t2 = ( $target - $t1 ) / 256;

        #
        # Update the compiled file on-disk.  (Remember the seek?)
        #
        print $tmp chr $t1;
        print $tmp chr $t2;

        #
        # Close again.  Inefficient if we have >N labels..
        #
        close($tmp);
    }
}
