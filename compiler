#!/usr/bin/perl -w
#
#  This is a simple compiler which will read an input file
# and spit out the corresponding bytecodes for the program.
#
#  The only real complexity comes from having to account for labels
# as our virtual machine only understands absolute jumping.
#
#      e.g. Rather than "jmp +3", or "jmp -8" we can only write
#           "jump address", where "address" is an integer 0-64k.
#
#  To cope with this we initially write all jump-targets as
# "JMP 0x0000" and keep track of the length of each instruction
# we've generated.
#
#  After the whole program has been compiled we can go back and fill
# in the absolute/real destination for the jumps.
#
#  Not ideal, but it is simpler than either parsing for-real or
# using a multi-pass parser.
#
#
# Steve
# --
#


use strict;
use warnings;


#
#  These are the bytecodes we understand.
#
use constant EXIT => 0x00;

#
#  Store items.
#
use constant STORE_STRING => 0x01;
use constant STORE_INT    => 0x02;

#
#  Print registers.
#
use constant PRINT_STRING => 0x03;
use constant PRINT_INT    => 0x04;

#
#  Jumps
#
use constant JUMP_TO => 0x06;
use constant JUMP_Z  => 0x07;
use constant JUMP_NZ => 0x08;


#
#  Mathematical
#
use constant ADD_OP => 0x09;
use constant SUB_OP => 0x0A;
use constant MUL_OP => 0x0B;
use constant DIV_OP => 0x0C;


#
#  System
#
use constant SYSTEM_STRING => 0x0D;


#
#  Increment/decrement the register contents
#
use constant INC_OP => 0x0E;
use constant DEC_OP => 0x0F;


#
#  Labels - All are downcased and must be unique per-source.
#
my %LABELS;


#
#  A running list of the jump-destinations we've got to update
# post-compilation - see the note in the header.
#
my @UPDATES;




#
#  Get the input file we'll parse
#
while ( my $file = shift )
{

    #
    #  Compiled programs have the same basename, but will have a .raw
    # suffix appended.
    #
    my $output = $file;
    $output =~ s/\.[^.]+$//;
    $output .= ".raw";

    #
    #  Open our input/output files.
    #
    open( my $in,  "<", $file )   or die "Failed to read source $file - $!";
    open( my $out, ">", $output ) or die "Failed to write to $output - $!";


    #
    #  Amount of instructions we've output.
    #
    #  This is label-related.
    #
    my $offset = 0;

    #
    #  Process each line of the input
    #
    while ( my $line = <$in> )
    {

        #
        #  Except comments / empty lines.
        #
        chomp($line);
        next if ( !length($line) || ( $line =~ /^\s*#/ ) );


        #
        #  Label definition ":foo"
        #
        if ( $line =~ /^\s*:(.*)/ )
        {
            my $name = $1;
            $LABELS{ $name } = $offset;

            # so we found a label - store the offset of the code in our array.
        }
        elsif ( $line =~ /^\s*store\s+#([0-9]+), ([0-9]+)/ )
        {
            my $reg = $1;
            my $val = $2;

            die "Int too large" if ( $val >= 65535 );

            my $val1 = $val % 256;
            my $val2 = ( $val - $val1 ) / 256;

            print $out chr STORE_INT;
            print $out chr $reg;
            print $out chr $val1;
            print $out chr $val2;

            $offset += 4;
        }
        elsif ( $line =~ /^\s+exit/ )
        {
            print $out chr EXIT;
            $offset += 1;
        }
        elsif ( $line =~ /^\s+store\s+#([0-9]+),\s?"([^"]+)"/ )
        {
            my $reg = $1;
            my $str = $2;
            my $len = length($str);

            print $out chr STORE_STRING;
            print $out chr $reg;
            print $out chr $len;
            print $out $str;

            $offset += 3;              # store + reg + len
            $offset += length($str);
        }
        elsif ( $line =~ /^\s*print_int\s?#(.*)/ )
        {
            my $reg = $1;
            print $out chr PRINT_INT;
            print $out chr $reg;

            $offset += 2;
        }
        elsif ( $line =~ /^\s*print_str\s?#(.*)/ )
        {
            my $reg = $1;
            print $out chr PRINT_STRING;
            print $out chr $reg;

            $offset += 2;
        }
        elsif ( $line =~ /^\s*system\s?#(.*)/ )
        {
            my $reg = $1;
            print $out chr SYSTEM_STRING;
            print $out chr $reg;

            $offset += 2;
        }
        elsif ( $line =~ /^\s*goto\s+([^ ]+)/ )
        {
            my $label = $1;

            print $out chr JUMP_TO;
            print $out chr 0;    # this will be updated.
            print $out chr 0;    # this will be updated.

            $offset += 3;        # jump + val1 + val2

            #
            # we now need to record the fact we have to patch up this
            # instruction.
            #
            push( @UPDATES,
                  {  offset => ( $offset - 2 ),
                     label  => $label
                  } );
        }
        elsif ( $line =~ /^\s*jmpz\s+([^ ]+)/ )
        {
            my $label = $1;

            print $out chr JUMP_Z;
            print $out chr 0;    # this will be updated.
            print $out chr 0;    # this will be updated.

            $offset += 3;        # jump + val1 + val2

            #
            # we now need to record the fact we have to patch up this
            # instruction.
            #
            push( @UPDATES,
                  {  offset => ( $offset - 2 ),
                     label  => $label
                  } );
        }
        elsif ( $line =~ /^\s*jmpnz\s+([^ ]+)/ )
        {
            my $label = $1;

            print $out chr JUMP_NZ;
            print $out chr 0;    # this will be updated.
            print $out chr 0;    # this will be updated.

            $offset += 3;        # jump + val1 + val2

            #
            # we now need to record the fact we have to patch up this
            # instruction.
            #
            push( @UPDATES,
                  {  offset => ( $offset - 2 ),
                     label  => $label
                  } );
        }
        elsif ( $line =~ /^\s*add\s+#([0-9]+)\s*,\s*#([0-9]+)\s*,\s*#([0-9]+)/ )
        {
            my $dest = $1;
            my $src1 = $2;
            my $src2 = $3;

            print $out chr ADD_OP;
            print $out chr $dest;
            print $out chr $src1;
            print $out chr $src2;

            $offset += 4;    # add + dest + src1 + src2
        }
        elsif ( $line =~ /^\s*sub\s+#([0-9]+)\s*,\s*#([0-9]+)\s*,\s*#([0-9]+)/ )
        {
            my $dest = $1;
            my $src1 = $2;
            my $src2 = $3;

            print $out chr SUB_OP;
            print $out chr $dest;
            print $out chr $src1;
            print $out chr $src2;

            $offset += 4;    # sub + dest + src1 + src2
        }
        elsif ( $line =~ /^\s*mul\s+#([0-9]+)\s*,\s*#([0-9]+)\s*,\s*#([0-9]+)/ )
        {
            my $dest = $1;
            my $src1 = $2;
            my $src2 = $3;

            print $out chr MUL_OP;
            print $out chr $dest;
            print $out chr $src1;
            print $out chr $src2;

            $offset += 4;    # mul + dest + src1 + src2
        }
        elsif ( $line =~ /^\s*div\s+#([0-9]+)\s*,\s*#([0-9]+)\s*,\s*#([0-9]+)/ )
        {
            my $dest = $1;
            my $src1 = $2;
            my $src2 = $3;

            print $out chr DIV_OP;
            print $out chr $dest;
            print $out chr $src1;
            print $out chr $src2;

            $offset += 4;    # add + dest + src1 + src2
        }
        elsif ( $line =~ /^\s*dec\s+#([0-9]+)/ )
        {
            my $reg = $1;

            print $out chr DEC_OP;
            print $out chr $reg;

            $offset += 2;    # dec + reg
        }
        elsif ( $line =~ /^\s*inc\s+#([0-9]+)/ )
        {
            my $reg = $1;

            print $out chr INC_OP;
            print $out chr $reg;

            $offset += 2;    # INC + reg
        }
        else
        {
            print "WARNING UNKNOWN LINE: $line\n";
        }
    }


    close($in);
    close($out);

    #
    #  OK now this is nasty - we want to go back and patch up the jump
    # instructions we know we've emitted.
    #
    foreach my $update (@UPDATES)
    {
        my $offset = $update->{ 'offset' };
        my $label  = $update->{ 'label' };

        #
        #  Open for in-place editing and make sure we're at the right spot.
        #
        open( my $tmp, "+<", $output ) or die "Failed to write to output - $!";
        seek $tmp, $offset, 0;

        #
        # now we find the target of the label
        #
        my $target = $LABELS{ $label };
        die "No target for label '$label'" unless ( defined($target) );

        #
        # Split the address into two bytes.
        #
        my $t1 = $target % 256;
        my $t2 = ( $target - $t1 ) / 256;

        #
        # Update the compiled file on-disk.  (Remember the seek?)
        #
        print $tmp chr $t1;
        print $tmp chr $t2;

        #
        # Close again.  Inefficient if we have >N labels..
        #
        close($tmp);
    }
}
