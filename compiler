#!/usr/bin/perl -w
#
#  This is a simple "compiler" which will read an input file
# and spit out the corresponding bytecodes for the program.
#
# Steve
# --
#


use strict;
use warnings;


use constant EXIT => 0x00;

use constant STORE_STRING => 0x01;
use constant STORE_INT    => 0x02;
use constant PRINT_STRING => 0x03;
use constant PRINT_INT    => 0x04;
use constant JUMP_TO      => 0x06;


#
#  Amount of instructions we've output.
#
#  This is used for labeling-purposes
#
my $offset = 0;

#
#  Labels - ALl are downcased and must be unique per-source.
#
my %LABELS;


while ( my $line = <DATA> )
{
    chomp($line);
    next if ( !length($line) || ( $line =~ /^#/ ) );

    if ( $line =~ /^:(.*)/ )
    {
        my $name = $1;
        $LABELS{ $name } = $offset;
    }

    if ( $line =~ /store\s+#([0-9]+), ([0-9]+)/ )
    {
        my $reg = $1;
        my $val = $2;

        die "Int too large" if ( $val >= 65535 );

        my $val1 = $val % 256;
        my $val2 = ( $val - $val1 ) / 256;

        print chr STORE_INT;
        print chr $reg;
        print chr $val1;
        print chr $val2;

        $offset += 4;
    }

    if ( $line =~ /store\s+#([0-9]+),\s?"([^"]+)"/ )
    {
        my $reg = $1;
        my $str = $2;
        my $len = length($str);

        print chr STORE_STRING;
        print chr $reg;
        print chr $len;
        print $str;

        $offset += 3;    # store + reg + len
        $offset += length($str);
    }

    if ( $line =~ /goto\s+:(.*)/ )
    {
        my $lab = $1;

        if ( defined $LABELS{ $lab } )
        {
            print chr JUMP_TO;
            print chr($offset);
        }
        else
        {
            die "Undefined label\n";
        }
    }
    if ( $line =~ /print_int\s?#(.*)/ )
    {
        my $reg = $1;
        print chr PRINT_INT;
        print chr $reg;

        $offset += 2;

    }

    if ( $line =~ /print_str\s?#(.*)/ )
    {
        my $reg = $1;
        print chr PRINT_STRING;
        print chr $reg;

        $offset += 2;
    }

    if ( $line =~ /jump\s+([0-9]+)/ )
    {
        my $dst = $1;

        die "Int too large" if ( $dst >= 65535 );

        my $d1 = $dst % 256;
        my $d2 = ( $dst - $d1 ) / 256;

        print chr JUMP_TO;
        print chr $d1;
        print chr $d2;

        $offset += 3;
    }
}


__DATA__

:label
  store #1, "Steve Kemp"
  print_str #1

  store #1, 32
  print_int #1

  jump 0
